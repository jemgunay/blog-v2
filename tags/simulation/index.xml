<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simulation on Jem Gunay</title><link>https://jemgunay.co.uk/tags/simulation/</link><description>Recent content in Simulation on Jem Gunay</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 10 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://jemgunay.co.uk/tags/simulation/index.xml" rel="self" type="application/rss+xml"/><item><title>Evolutionary Driving with Genetic Algorithms</title><link>https://jemgunay.co.uk/p/evolutionary-driving-with-genetic-algorithms/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://jemgunay.co.uk/p/evolutionary-driving-with-genetic-algorithms/</guid><description>&lt;img src="https://jemgunay.co.uk/p/evolutionary-driving-with-genetic-algorithms/preview.png" alt="Featured image of post Evolutionary Driving with Genetic Algorithms" />&lt;p>See the GitHub repository &lt;a class="link" href="https://github.com/jemgunay/evolutionary-driving" target="_blank" rel="noopener"
>here&lt;/a>.&lt;/p>
&lt;p>I&amp;rsquo;m a massive fan of the Box2D physics engine and have wielded it in a few languages as part of game and simulation
projects. I spotted a &lt;a class="link" href="https://github.com/ByteArena/box2d" target="_blank" rel="noopener"
>Go port&lt;/a> and wanted to somehow combine this with the Pixel 2D
game library and
decided &lt;a class="link" href="http://domasx2.github.io/gamejs-box2d-car-example/" target="_blank" rel="noopener"
>this&lt;/a> top-down car demo written in JS with Box2D would be a
fun base to start with. So, I went ahead and migrated it to Go with Pixel &amp;amp; Box2D, adding enhancements such as vehicle
health and destruction.&lt;/p>
&lt;p>I&amp;rsquo;d studied evolutionary algorithms at uni but had never actually implemented them. I decided to encode the car&amp;rsquo;s
movements as a genetic sequence, and iteratively evolve the car&amp;rsquo;s performance in order to solve a basic problem. The car
evolves to drive to and gracefully brake on a green target point. It uses roulette wheel selection combined with random
cross-overs, swaps and mutations to produce the following generation. The fitness function is a combination of the
distance from the target and the final velocity at the end of the sequence execution to encourage the car to precisely
park on the target rather than speed over it.&lt;/p>
&lt;p>The following video illustrates the improvement in fitness between evolutionary iterations. I&amp;rsquo;ve also included a
surprising solution which evolved after hundreds of iterations, showing how machine learning and evolution in general
can provide interesting and less obvious solutions&amp;hellip;&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/F2pwEOJhNMs"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div></description></item><item><title>C++ Orbital Simulation (Part 2)</title><link>https://jemgunay.co.uk/p/orbital-simulation-part-2/</link><pubDate>Tue, 26 Sep 2017 00:00:00 +0000</pubDate><guid>https://jemgunay.co.uk/p/orbital-simulation-part-2/</guid><description>&lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/preview.jpg" alt="Featured image of post C++ Orbital Simulation (Part 2)" />&lt;p>See the GitHub repository &lt;a class="link" href="https://github.com/jemgunay/orbital-sim" target="_blank" rel="noopener"
>here&lt;/a>.&lt;/p>
&lt;p>As a follow-up to &lt;a class="link" href="https://jemgunay.co.uk/p/orbital-simulation-part-1" >Part 1&lt;/a>, I decided to rewrite the orbital planet simulation from scratch, this time scrapping the
physics library and instead implementing my own physics. On launch, three galaxies consisting of around 100 planets each
are spawned which orbit a larger planet sitting at the centre of their galaxy. These planets are all gravitationally
attracted towards each other and deflect on collision.&lt;/p>
&lt;p>Each planet has a randomised size, shape and texture; smaller planets are given an initial impulse to push them into an
orbit. The controllable rocket can be used to navigate the cosmos and its physics are also simulated; the rocket vector
graphic was created in Adobe Illustrator.&lt;/p>
&lt;p>&lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame.jpg"
width="1936"
height="1056"
srcset="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame_hu1460826660553803094.jpg 480w, https://jemgunay.co.uk/p/orbital-simulation-part-2/frame_hu13884898411630764141.jpg 1024w"
loading="lazy"
alt="Example simulation"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
> &lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame2.jpg"
width="1936"
height="1056"
srcset="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame2_hu15577714237923668406.jpg 480w, https://jemgunay.co.uk/p/orbital-simulation-part-2/frame2_hu9042251298951106865.jpg 1024w"
loading="lazy"
alt="Example simulation"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
> &lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame3.jpg"
width="1936"
height="1056"
srcset="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame3_hu11063349811697599931.jpg 480w, https://jemgunay.co.uk/p/orbital-simulation-part-2/frame3_hu12710098379079281343.jpg 1024w"
loading="lazy"
alt="Example simulation"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>&lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame4.jpg"
width="1936"
height="1056"
srcset="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame4_hu14813374577102209948.jpg 480w, https://jemgunay.co.uk/p/orbital-simulation-part-2/frame4_hu3042348197284961574.jpg 1024w"
loading="lazy"
alt="Example simulation"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
> &lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame5.jpg"
width="1936"
height="1056"
srcset="https://jemgunay.co.uk/p/orbital-simulation-part-2/frame5_hu10457035373088277041.jpg 480w, https://jemgunay.co.uk/p/orbital-simulation-part-2/frame5_hu6609331672162152360.jpg 1024w"
loading="lazy"
alt="Vector rocket graphic creation in Illustrator"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>The simulation can be seen in action below:&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/0GOfqRuKk8A"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div></description></item><item><title>Trippy Recursive Circles in Processing</title><link>https://jemgunay.co.uk/p/trippy-recursive-circles-in-processing/</link><pubDate>Mon, 19 Sep 2016 03:19:37 +0000</pubDate><guid>https://jemgunay.co.uk/p/trippy-recursive-circles-in-processing/</guid><description>&lt;img src="https://jemgunay.co.uk/p/trippy-recursive-circles-in-processing/preview.png" alt="Featured image of post Trippy Recursive Circles in Processing" />&lt;p>Simple use of recursion to make a warped tunnelling effect with circles using &lt;a class="link" href="https://processing.org/" target="_blank" rel="noopener"
>Processing&lt;/a>.
Processing sketch/source and compiled executable can be found below.&lt;/p>
&lt;ul>
&lt;li>Starts off slowly iterating over the four different rendering modes.&lt;/li>
&lt;li>Use keys 1, 2, 3 and 4 to change the visual/render mode (dynamic rainbow, static rainbow, dynamic greyscale, static
greyscale).&lt;/li>
&lt;li>Use left and right arrow keys to switch to a different motion path (there are 4 motion paths, each with varied use of
the trigonometric functions sin, cos and tan).&lt;/li>
&lt;/ul>
&lt;p>TODO: Click to download application &amp;amp; source files&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/qIsaU927Jxs"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div></description></item><item><title>C++ Orbital Simulation (Part 1)</title><link>https://jemgunay.co.uk/p/orbital-simulation-part-1/</link><pubDate>Sun, 18 Sep 2016 21:05:26 +0000</pubDate><guid>https://jemgunay.co.uk/p/orbital-simulation-part-1/</guid><description>&lt;img src="https://jemgunay.co.uk/p/orbital-simulation-part-1/preview.png" alt="Featured image of post C++ Orbital Simulation (Part 1)" />&lt;p>I was curious about using the &lt;a class="link" href="https://github.com/erincatto/Box2D" target="_blank" rel="noopener"
>Box2D&lt;/a> physics engine to simulate orbital physics,
inspired by the gravitational pull mechanic of the planets in Angry Birds Space. The &lt;a class="link" href="http://www.sfml-dev.org" target="_blank" rel="noopener"
>SFML&lt;/a>
library was used to draw the planets in the simulation. Planet Earth is fixed to the centre of space, with a variable
number of square and triangular satellites orbiting around it; for each satellite spawned, an impulse sized relative to
the distance from the central planet is applied to launch it in a random direction, but with a velocity which guides the
satellite into a stable orbit. I decided to use an abstract but clean style to make the simulation more interesting and
satisfying to watch.&lt;/p>
&lt;p>There are options to create and destroy satellites, which can in turn be dragged around with the mouse - a challenge is
to try and throw the satellites back into a successful orbit. There are also controls for zooming and enabling/disabling
the gravitational field which creates a gradual scattering effect. I intend to revisit the orbital test to create a more
realistic and complex simulation or game.&lt;/p>
&lt;p>The simulation can be seen in action below, followed by the program download link.&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/qlLprQlhRuk"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>TODO: Click to download&lt;/p></description></item></channel></rss>